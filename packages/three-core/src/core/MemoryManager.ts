import * as THREE from 'three';
import type { Manager } from '@react-face/shared-types';
import { createSignal } from './Signal';

export interface MemoryInfo {
  geometries: number;
  textures: number;
  materials: number;
  objects: number;
  totalMemory: number;
  timestamp: number;
}

export interface LeakInfo {
  type: 'geometry' | 'texture' | 'material' | 'object';
  id: string;
  size: number;
  lastUsed: number;
  potentialLeak: boolean;
}

export interface MemoryConfig {
  enabled?: boolean;
  checkInterval?: number;
  maxMemoryUsage?: number;
  maxIdleTime?: number;
  autoCleanup?: boolean;
  logToConsole?: boolean;
}

export class MemoryManager implements Manager {
  private engine: any;
  private config: MemoryConfig;
  private memoryHistory: MemoryInfo[] = [];
  private leakDetector: Map<string, LeakInfo> = new Map();
  private isMonitoring: boolean = false;
  private checkInterval: number = 5000; // 5ÁßíÊ£ÄÊü•‰∏ÄÊ¨°

  // ‰ø°Âè∑
  public readonly memoryUpdated = createSignal<MemoryInfo | null>(null);
  public readonly leakDetected = createSignal<LeakInfo[] | null>(null);
  public readonly memoryWarning = createSignal<string>('');
  public readonly cleanupStarted = createSignal<void>(undefined);
  public readonly cleanupCompleted = createSignal<{ cleaned: number; freed: number } | null>(null);

  constructor(engine: any, config: MemoryConfig = {}) {
    this.engine = engine;
    this.config = {
      enabled: true,
      checkInterval: 5000,
      maxMemoryUsage: 100 * 1024 * 1024, // 100MB
      maxIdleTime: 300000, // 5ÂàÜÈíü
      autoCleanup: true,
      logToConsole: false,
      ...config
    };
  }

  async initialize(): Promise<void> {
    console.log('üß† MemoryManager initialized');
    
    if (this.config.enabled) {
      this.startMonitoring();
    }
  }

  dispose(): void {
    this.stopMonitoring();
    this.memoryHistory = [];
    this.leakDetector.clear();
    // Signal‰∏çÈúÄË¶ÅÊâãÂä®disposeÔºå‰ºöËá™Âä®Ê∏ÖÁêÜ
  }

  // ÂºÄÂßãÁõëÊéß
  startMonitoring(): void {
    if (this.isMonitoring) return;

    this.isMonitoring = true;
    this.checkInterval = this.config.checkInterval || 5000;

    const monitor = () => {
      if (!this.isMonitoring) return;

      this.checkMemoryUsage();
      this.detectLeaks();
      this.autoCleanup();

      setTimeout(monitor, this.checkInterval);
    };

    monitor();
  }

  // ÂÅúÊ≠¢ÁõëÊéß
  stopMonitoring(): void {
    this.isMonitoring = false;
  }

  // Ê£ÄÊü•ÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµ
  private checkMemoryUsage(): void {
    const renderer = this.engine.getManager('renderer')?.instance?.renderer;
    if (!renderer) return;

    const info = renderer.info;
    const memory = info.memory;

    const memoryInfo: MemoryInfo = {
      geometries: memory.geometries,
      textures: memory.textures,
      materials: memory.materials || 0,
      objects: this.getObjectCount(),
      totalMemory: this.calculateTotalMemory(memory),
      timestamp: Date.now()
    };

    this.memoryHistory.push(memoryInfo);
    
    // ÈôêÂà∂ÂéÜÂè≤ËÆ∞ÂΩïÊï∞Èáè
    if (this.memoryHistory.length > 100) {
      this.memoryHistory.shift();
    }

    this.memoryUpdated.emit(memoryInfo);

    // Ê£ÄÊü•ÂÜÖÂ≠òË≠¶Âëä
    if (memoryInfo.totalMemory > this.config.maxMemoryUsage!) {
      this.memoryWarning.emit(`ÂÜÖÂ≠ò‰ΩøÁî®ËøáÈ´ò: ${(memoryInfo.totalMemory / 1024 / 1024).toFixed(2)}MB`);
    }

    if (this.config.logToConsole) {
      console.log('üß† Memory:', memoryInfo);
    }
  }

  // Ê£ÄÊµãÂÜÖÂ≠òÊ≥ÑÊºè
  private detectLeaks(): void {
    const leaks: LeakInfo[] = [];
    const now = Date.now();
    const maxIdleTime = this.config.maxIdleTime!;

    // Ê£ÄÊü•Âá†‰Ωï‰ΩìÊ≥ÑÊºè
    const geometryManager = this.engine.getManager('geometries')?.instance;
    if (geometryManager) {
      const geometries = geometryManager.getAllGeometries();
      geometries.forEach((geometry: any) => {
        const lastUsed = geometry.userData?.lastUsed || 0;
        const idleTime = now - lastUsed;
        
        if (idleTime > maxIdleTime) {
          const leakInfo: LeakInfo = {
            type: 'geometry',
            id: geometry.uuid,
            size: this.estimateGeometrySize(geometry),
            lastUsed,
            potentialLeak: true
          };
          leaks.push(leakInfo);
          this.leakDetector.set(geometry.uuid, leakInfo);
        }
      });
    }

    // Ê£ÄÊü•Á∫πÁêÜÊ≥ÑÊºè
    const textureManager = this.engine.getManager('textures')?.instance;
    if (textureManager) {
      const textures = textureManager.getAllTextures();
      textures.forEach((texture: any) => {
        const lastUsed = texture.userData?.lastUsed || 0;
        const idleTime = now - lastUsed;
        
        if (idleTime > maxIdleTime) {
          const leakInfo: LeakInfo = {
            type: 'texture',
            id: texture.uuid,
            size: this.estimateTextureSize(texture),
            lastUsed,
            potentialLeak: true
          };
          leaks.push(leakInfo);
          this.leakDetector.set(texture.uuid, leakInfo);
        }
      });
    }

    // Ê£ÄÊü•ÊùêË¥®Ê≥ÑÊºè
    const materialManager = this.engine.getManager('materials')?.instance;
    if (materialManager) {
      const materials = materialManager.getAllMaterials();
      materials.forEach((material: any) => {
        const lastUsed = material.userData?.lastUsed || 0;
        const idleTime = now - lastUsed;
        
        if (idleTime > maxIdleTime) {
          const leakInfo: LeakInfo = {
            type: 'material',
            id: material.uuid,
            size: this.estimateMaterialSize(material),
            lastUsed,
            potentialLeak: true
          };
          leaks.push(leakInfo);
          this.leakDetector.set(material.uuid, leakInfo);
        }
      });
    }

    if (leaks.length > 0) {
      this.leakDetected.emit(leaks);
      
      if (this.config.logToConsole) {
        console.warn('‚ö†Ô∏è Ê£ÄÊµãÂà∞ÊΩúÂú®ÂÜÖÂ≠òÊ≥ÑÊºè:', leaks);
      }
    }
  }

  // Ëá™Âä®Ê∏ÖÁêÜ
  private autoCleanup(): void {
    if (!this.config.autoCleanup) return;

    const leaks = this.leakDetector.values();
    const now = Date.now();
    const maxIdleTime = this.config.maxIdleTime!;

    let cleaned = 0;
    let freed = 0;

    for (const leak of leaks) {
      const idleTime = now - leak.lastUsed;
      
      if (idleTime > maxIdleTime * 2) { // Ë∂ÖËøá2ÂÄçÁ©∫Èó≤Êó∂Èó¥ÊâçÊ∏ÖÁêÜ
        const success = this.cleanupResource(leak.type, leak.id);
        if (success) {
          cleaned++;
          freed += leak.size;
          this.leakDetector.delete(leak.id);
        }
      }
    }

    if (cleaned > 0) {
      this.cleanupCompleted.emit({ cleaned, freed });
      
      if (this.config.logToConsole) {
        console.log(`üßπ Ëá™Âä®Ê∏ÖÁêÜÂÆåÊàê: Ê∏ÖÁêÜ‰∫Ü ${cleaned} ‰∏™ËµÑÊ∫êÔºåÈáäÊîæ‰∫Ü ${(freed / 1024).toFixed(2)}KB ÂÜÖÂ≠ò`);
      }
    }
  }

  // ÊâãÂä®Ê∏ÖÁêÜËµÑÊ∫ê
  cleanupResource(type: string, id: string): boolean {
    try {
      switch (type) {
        case 'geometry':
          const geometryManager = this.engine.getManager('geometries')?.instance;
          if (geometryManager) {
            return geometryManager.removeGeometry(id);
          }
          break;

        case 'texture':
          const textureManager = this.engine.getManager('textures')?.instance;
          if (textureManager) {
            return textureManager.removeTexture(id);
          }
          break;

        case 'material':
          const materialManager = this.engine.getManager('materials')?.instance;
          if (materialManager) {
            return materialManager.removeMaterial(id);
          }
          break;

        case 'object':
          const objectManager = this.engine.getManager('objects')?.instance;
          if (objectManager) {
            return objectManager.removeObject(id);
          }
          break;
      }
    } catch (error) {
      console.error('Ê∏ÖÁêÜËµÑÊ∫êÂ§±Ë¥•:', error);
    }
    
    return false;
  }

  // Âº∫Âà∂Ê∏ÖÁêÜÊâÄÊúâÊú™‰ΩøÁî®ÁöÑËµÑÊ∫ê
  forceCleanup(): { cleaned: number; freed: number } {
    this.cleanupStarted.emit();

    let cleaned = 0;
    let freed = 0;

    // Ê∏ÖÁêÜÂá†‰Ωï‰Ωì
    const geometryManager = this.engine.getManager('geometries')?.instance;
    if (geometryManager) {
      const geometries = geometryManager.getAllGeometries();
      geometries.forEach((geometry: any) => {
        if (!geometry.userData?.inUse) {
          const size = this.estimateGeometrySize(geometry);
          if (geometryManager.removeGeometry(geometry.uuid)) {
            cleaned++;
            freed += size;
          }
        }
      });
    }

    // Ê∏ÖÁêÜÁ∫πÁêÜ
    const textureManager = this.engine.getManager('textures')?.instance;
    if (textureManager) {
      const textures = textureManager.getAllTextures();
      textures.forEach((texture: any) => {
        if (!texture.userData?.inUse) {
          const size = this.estimateTextureSize(texture);
          if (textureManager.removeTexture(texture.uuid)) {
            cleaned++;
            freed += size;
          }
        }
      });
    }

    // Ê∏ÖÁêÜÊùêË¥®
    const materialManager = this.engine.getManager('materials')?.instance;
    if (materialManager) {
      const materials = materialManager.getAllMaterials();
      materials.forEach((material: any) => {
        if (!material.userData?.inUse) {
          const size = this.estimateMaterialSize(material);
          if (materialManager.removeMaterial(material.uuid)) {
            cleaned++;
            freed += size;
          }
        }
      });
    }

    // Ê∏ÖÁêÜÂØπË±°
    const objectManager = this.engine.getManager('objects')?.instance;
    if (objectManager) {
      const objects = objectManager.getAllObjects();
      objects.forEach((object: any) => {
        if (!object.userData?.inUse) {
          const size = this.estimateObjectSize(object);
          if (objectManager.removeObject(object.uuid)) {
            cleaned++;
            freed += size;
          }
        }
      });
    }

    this.cleanupCompleted.emit({ cleaned, freed });
    
    if (this.config.logToConsole) {
      console.log(`üßπ Âº∫Âà∂Ê∏ÖÁêÜÂÆåÊàê: Ê∏ÖÁêÜ‰∫Ü ${cleaned} ‰∏™ËµÑÊ∫êÔºåÈáäÊîæ‰∫Ü ${(freed / 1024).toFixed(2)}KB ÂÜÖÂ≠ò`);
    }

    return { cleaned, freed };
  }

  // ‰º∞ÁÆóÂá†‰Ωï‰ΩìÂ§ßÂ∞è
  private estimateGeometrySize(geometry: THREE.BufferGeometry): number {
    let size = 0;
    
    if (geometry.attributes.position) {
      size += geometry.attributes.position.count * 3 * 4; // 3‰∏™float32
    }
    if (geometry.attributes.normal) {
      size += geometry.attributes.normal.count * 3 * 4;
    }
    if (geometry.attributes.uv) {
      size += geometry.attributes.uv.count * 2 * 4;
    }
    if (geometry.index) {
      size += geometry.index.count * 2; // uint16
    }
    
    return size;
  }

  // ‰º∞ÁÆóÁ∫πÁêÜÂ§ßÂ∞è
  private estimateTextureSize(texture: THREE.Texture): number {
    if (!texture.image) return 0;
    
    const width = texture.image.width || 1;
    const height = texture.image.height || 1;
    const channels = 4; // RGBA
    
    return width * height * channels;
  }

  // ‰º∞ÁÆóÊùêË¥®Â§ßÂ∞è
  private estimateMaterialSize(material: THREE.Material): number {
    // ÊùêË¥®Êú¨Ë∫´ÂæàÂ∞èÔºå‰∏ªË¶ÅÊòØÂºïÁî®
    return 1024; // 1KB ‰º∞ÁÆó
  }

  // ‰º∞ÁÆóÂØπË±°Â§ßÂ∞è
  private estimateObjectSize(object: THREE.Object3D): number {
    // ÂØπË±°Êú¨Ë∫´ÂæàÂ∞èÔºå‰∏ªË¶ÅÊòØÂºïÁî®
    return 512; // 0.5KB ‰º∞ÁÆó
  }

  // ËÆ°ÁÆóÊÄªÂÜÖÂ≠ò‰ΩøÁî®
  private calculateTotalMemory(memory: any): number {
    let total = 0;
    
    // Âá†‰Ωï‰ΩìÂÜÖÂ≠ò
    total += memory.geometries * 1024; // ÊØè‰∏™Âá†‰Ωï‰Ωì‰º∞ÁÆó1KB
    
    // Á∫πÁêÜÂÜÖÂ≠ò
    total += memory.textures * 1024 * 1024; // ÊØè‰∏™Á∫πÁêÜ‰º∞ÁÆó1MB
    
    return total;
  }

  // Ëé∑ÂèñÂØπË±°Êï∞Èáè
  private getObjectCount(): number {
    const objectManager = this.engine.getManager('objects')?.instance;
    return objectManager ? objectManager.getAllObjects().length : 0;
  }

  // Ëé∑ÂèñÂÜÖÂ≠òÊï∞ÊçÆ
  getMemoryData(): MemoryInfo[] {
    return [...this.memoryHistory];
  }

  // Ëé∑ÂèñÊúÄÊñ∞ÂÜÖÂ≠ò‰ø°ÊÅØ
  getLatestMemory(): MemoryInfo | null {
    return this.memoryHistory[this.memoryHistory.length - 1] || null;
  }

  // Ëé∑ÂèñÊ≥ÑÊºèÊ£ÄÊµãÂô®Êï∞ÊçÆ
  getLeakDetectorData(): LeakInfo[] {
    return Array.from(this.leakDetector.values());
  }

  // ËÆæÁΩÆÈÖçÁΩÆ
  setConfig(config: Partial<MemoryConfig>): void {
    this.config = { ...this.config, ...config };
    
    if (config.checkInterval) {
      this.checkInterval = config.checkInterval;
    }
  }

  // Ëé∑ÂèñÈÖçÁΩÆ
  getConfig(): MemoryConfig {
    return { ...this.config };
  }

  // Ê†áËÆ∞ËµÑÊ∫ê‰∏∫‰ΩøÁî®‰∏≠
  markResourceAsUsed(type: string, id: string): void {
    const resource = this.getResource(type, id);
    if (resource) {
      resource.userData = resource.userData || {};
      resource.userData.lastUsed = Date.now();
      resource.userData.inUse = true;
    }
  }

  // Ê†áËÆ∞ËµÑÊ∫ê‰∏∫Êú™‰ΩøÁî®
  markResourceAsUnused(type: string, id: string): void {
    const resource = this.getResource(type, id);
    if (resource) {
      resource.userData = resource.userData || {};
      resource.userData.inUse = false;
    }
  }

  // Ëé∑ÂèñËµÑÊ∫ê
  private getResource(type: string, id: string): any {
    switch (type) {
      case 'geometry':
        const geometryManager = this.engine.getManager('geometries')?.instance;
        return geometryManager?.getGeometry(id);
      case 'texture':
        const textureManager = this.engine.getManager('textures')?.instance;
        return textureManager?.getTexture(id);
      case 'material':
        const materialManager = this.engine.getManager('materials')?.instance;
        return materialManager?.getMaterial(id);
      case 'object':
        const objectManager = this.engine.getManager('objects')?.instance;
        return objectManager?.getObject(id);
      default:
        return null;
    }
  }
} 